import { Pipe, EventEmitter, Component, forwardRef, HostBinding, Input, Output, ViewChild, HostListener, NgModule } from '@angular/core';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import { coerceBooleanProperty } from '@angular/cdk/coercion';
import { CommonModule } from '@angular/common';
import { MatChipsModule } from '@angular/material/chips';
import { MatIconModule } from '@angular/material/icon';
import { MatTooltipModule } from '@angular/material/tooltip';

class BytePipe {
    constructor() {
        this.unit = 'Bytes';
    }
    transform(value, decimals) {
        value = value.toString();
        if (parseInt(value, 10) >= 0) {
            value = this.formatBytes(+value, +decimals);
        }
        return value;
    }
    // https://stackoverflow.com/questions/15900485/correct-way-to-convert-size-in-bytes-to-kb-mb-gb-in-javascript
    formatBytes(bytes, decimals = 2) {
        if (bytes === 0) {
            return '0 Bytes';
        }
        const k = 1024;
        const dm = decimals < 0 ? 0 : decimals;
        const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
    }
}
BytePipe.decorators = [
    { type: Pipe, args: [{
                name: 'byte'
            },] }
];

class NgxFileDragDropComponent {
    constructor() {
        this.valueChanged = new EventEmitter();
        // does no validation, just sets the hidden file input
        this.accept = '*';
        this._disabled = false;
        this._multiple = false;
        this.emptyPlaceholder = `Drop file${this.multiple ? 's' : ''} or click to select`;
        this._displayFileSize = false;
        this._activeBorderColor = 'purple';
        this._files = [];
        this._isDragOver = false;
        // https://angular.io/api/forms/ControlValueAccessor
        this._onChange = (val) => { };
        this._onTouched = () => { };
    }
    get disabled() {
        return this._disabled;
    }
    set disabled(val) {
        this._disabled = coerceBooleanProperty(val);
    }
    set multiple(value) {
        this._multiple = coerceBooleanProperty(value);
    }
    get multiple() {
        return this._multiple;
    }
    set displayFileSize(value) {
        this._displayFileSize = coerceBooleanProperty(value);
    }
    get displayFileSize() {
        return this._displayFileSize;
    }
    set borderColor(color) {
        this._activeBorderColor = color;
    }
    get borderColor() {
        return this.isDragover ? this._activeBorderColor : '#ccc';
    }
    get files() {
        return this._files;
    }
    get isEmpty() {
        var _a;
        return !((_a = this.files) === null || _a === void 0 ? void 0 : _a.length);
    }
    // @HostBinding('class.drag-over')
    get isDragover() {
        return this._isDragOver;
    }
    set isDragover(value) {
        if (!this.disabled) {
            this._isDragOver = value;
        }
    }
    writeValue(files) {
        const fileArray = this.convertToArray(files);
        if (fileArray.length < 2 || this.multiple) {
            this._files = fileArray;
            this.emitChanges(this._files);
        }
        else {
            throw Error('Multiple files not allowed');
        }
    }
    registerOnChange(fn) {
        this._onChange = fn;
    }
    registerOnTouched(fn) {
        this._onTouched = fn;
    }
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    emitChanges(files) {
        this.valueChanged.emit(files);
        this._onChange(files);
    }
    addFiles(files) {
        // this._onTouched();
        const fileArray = this.convertToArray(files);
        if (this.multiple) {
            // this.errorOnEqualFilenames(fileArray);
            const merged = this.files.concat(fileArray);
            this.writeValue(merged);
        }
        else {
            this.writeValue(fileArray);
        }
    }
    removeFile(file) {
        const fileIndex = this.files.indexOf(file);
        if (fileIndex >= 0) {
            const currentFiles = this.files.slice();
            currentFiles.splice(fileIndex, 1);
            this.writeValue(currentFiles);
        }
    }
    clear() {
        this.writeValue([]);
    }
    change(event) {
        event.stopPropagation();
        this._onTouched();
        const fileList = event.target.files;
        if (fileList === null || fileList === void 0 ? void 0 : fileList.length) {
            this.addFiles(fileList);
        }
        // clear it so change is triggered if same file is selected again
        event.target.value = '';
    }
    activate(e) {
        e.preventDefault();
        this.isDragover = true;
    }
    deactivate(e) {
        e.preventDefault();
        this.isDragover = false;
    }
    handleDrop(e) {
        this.deactivate(e);
        if (!this.disabled) {
            const fileList = e.dataTransfer.files;
            this.removeDirectories(fileList).then((files) => {
                if (files === null || files === void 0 ? void 0 : files.length) {
                    this.addFiles(files);
                }
                this._onTouched();
            });
        }
    }
    open() {
        var _a;
        if (!this.disabled) {
            (_a = this.fileInputEl) === null || _a === void 0 ? void 0 : _a.nativeElement.click();
        }
    }
    // @HostListener('focusout')
    // blur() {
    //   console.log('blurred')
    //   this._onTouched();
    // }
    // private errorOnEqualFilenames(files: File[]) {
    //   if (this.files.some(file => files.some(file2 => file.name === file2.name))) {
    //     throw Error('one of the provided filenames already exists')
    //   }
    //   for (let i = 0; i < files.length; i++) {
    //     for (let j = i + 1; j < files.length; j++) {
    //       if (files[i].name === files[j].name) {
    //         throw Error(`can't add multiple files with same name`)
    //       }
    //     }
    //   }
    // }
    removeDirectories(files) {
        return new Promise((resolve, reject) => {
            const fileArray = this.convertToArray(files);
            const dirnames = [];
            const readerList = [];
            for (let i = 0; i < fileArray.length; i++) {
                const reader = new FileReader();
                reader.onerror = () => {
                    dirnames.push(fileArray[i].name);
                };
                reader.onloadend = () => addToReaderList(i);
                reader.readAsArrayBuffer(fileArray[i]);
            }
            function addToReaderList(val) {
                readerList.push(val);
                if (readerList.length === fileArray.length) {
                    resolve(fileArray.filter((file) => !dirnames.includes(file.name)));
                }
            }
        });
    }
    convertToArray(files) {
        if (files) {
            if (files instanceof File) {
                return [files];
            }
            else if (Array.isArray(files)) {
                return files;
            }
            else {
                return Array.prototype.slice.call(files);
            }
        }
        return [];
    }
    getFileName(file) {
        if (!this._displayFileSize) {
            return file.name;
        }
        const size = new BytePipe().transform(file.size);
        return `${file.name} (${size})`;
    }
}
NgxFileDragDropComponent.decorators = [
    { type: Component, args: [{
                selector: 'ngx-file-drag-drop',
                template: "<mat-chip-list *ngIf=\"files.length\" selectable=\"false\">\r\n    <mat-chip matTooltip={{file.size|byte}} matTooltipPosition=\"below\" [matTooltipDisabled]=\"displayFileSize\" selected\r\n        *ngFor=\"let file of files\" [disabled]=\"disabled\" color=\"accent\" disableRipple=\"true\" [removable]=\"!disabled\"\r\n        (removed)=\"removeFile(file)\">\r\n        <span class=\"filename\">{{getFileName(file)}}</span>\r\n        <mat-icon *ngIf=\"!disabled\" matChipRemove>cancel</mat-icon>\r\n    </mat-chip>\r\n</mat-chip-list>\r\n<span class=\"placeholder\" *ngIf=\"!files.length\">{{emptyPlaceholder}}</span>\r\n<input #fileInputEl class=\"hidden\" #fileInput type=\"file\" [attr.multiple]=\"multiple? '' : null\" [attr.accept]=\"accept\">",
                providers: [{
                        provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => NgxFileDragDropComponent),
                        multi: true
                    }],
                styles: ["input{height:0;opacity:0;overflow:hidden;position:absolute;width:0;z-index:-1}:host{border:2px dashed;border-radius:20px;cursor:pointer;display:block;margin:10px auto;max-width:500px;min-height:50px;padding:20px}:host.disabled{cursor:unset;opacity:.5}.placeholder{color:grey;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}mat-chip{max-width:100%}.filename{max-width:calc(100% - 1em);overflow:hidden;text-overflow:ellipsis;white-space:nowrap}:host.empty-input{align-items:center;display:flex;justify-content:center}.mat-chip.mat-standard-chip.mat-focus-indicator{box-shadow:none}.mat-chip.mat-standard-chip:after{background:unset}"]
            },] }
];
NgxFileDragDropComponent.ctorParameters = () => [];
NgxFileDragDropComponent.propDecorators = {
    disabled: [{ type: HostBinding, args: ['class.disabled',] }, { type: Input }],
    multiple: [{ type: Input }],
    displayFileSize: [{ type: Input }],
    borderColor: [{ type: Input, args: ['activeBorderColor',] }, { type: HostBinding, args: ['style.border-color',] }],
    isEmpty: [{ type: HostBinding, args: ['class.empty-input',] }],
    valueChanged: [{ type: Output }],
    fileInputEl: [{ type: ViewChild, args: ['fileInputEl',] }],
    accept: [{ type: Input }],
    emptyPlaceholder: [{ type: Input }],
    change: [{ type: HostListener, args: ['change', ['$event'],] }],
    activate: [{ type: HostListener, args: ['dragenter', ['$event'],] }, { type: HostListener, args: ['dragover', ['$event'],] }],
    deactivate: [{ type: HostListener, args: ['dragleave', ['$event'],] }],
    handleDrop: [{ type: HostListener, args: ['drop', ['$event'],] }],
    open: [{ type: HostListener, args: ['click',] }]
};

class NgxFileDragDropModule {
}
NgxFileDragDropModule.decorators = [
    { type: NgModule, args: [{
                declarations: [NgxFileDragDropComponent, BytePipe],
                imports: [
                    CommonModule,
                    MatChipsModule,
                    MatIconModule,
                    MatTooltipModule
                ],
                exports: [NgxFileDragDropComponent, BytePipe]
            },] }
];

// @dynamic
class FileValidators {
    static fileExtension(ext) {
        return (control) => {
            const validExtensions = ext.map(e => e.trim().toLowerCase());
            const fileArray = control.value;
            const invalidFiles = fileArray.map(file => file.name).filter(fname => {
                const extension = fname.slice((fname.lastIndexOf('.') - 1 >>> 0) + 2).toLowerCase();
                return !validExtensions.includes(extension);
            }).map(name => ({ name, ext: name.slice((name.lastIndexOf('.') - 1 >>> 0) + 2) }));
            return !invalidFiles.length
                ? null
                : {
                    fileExtension: {
                        requiredExtension: ext.toString(),
                        actualExtensions: invalidFiles
                    }
                };
        };
    }
    static uniqueFileNames(control) {
        const fileNameArray = control.value.map(file => file.name);
        const duplicates = fileNameArray.reduce((acc, curr) => {
            acc[curr] = acc[curr] ? acc[curr] + 1 : 1;
            return acc;
        }, {});
        const duplicatesArray = Object.entries(duplicates)
            .filter(arr => arr[1] > 1)
            .map(arr => ({ name: arr[0], count: arr[1] }));
        return !duplicatesArray.length
            ? null
            : {
                uniqueFileNames: { duplicatedFileNames: duplicatesArray }
            };
    }
    static fileType(types) {
        return (control) => {
            let regExp;
            if (Array.isArray(types)) {
                const joinedTypes = types.join('$|^');
                regExp = new RegExp(`$${joinedTypes}^`, 'i');
            }
            else {
                regExp = types;
            }
            const fileArray = control.value;
            const invalidFiles = fileArray.filter(file => !regExp.test(file.type)).map(file => ({ name: file.name, type: file.type }));
            return !invalidFiles.length
                ? null
                : {
                    fileType: {
                        requiredType: types.toString(),
                        actualTypes: invalidFiles
                    }
                };
        };
    }
    static maxFileCount(count) {
        return (control) => {
            const fileCount = (control === null || control === void 0 ? void 0 : control.value) ? control.value.length : 0;
            const result = count >= fileCount;
            return result
                ? null
                : {
                    maxFileCount: {
                        maxCount: count,
                        actualCount: fileCount
                    }
                };
        };
    }
    static maxFileSize(bytes) {
        return (control) => {
            const fileArray = control.value;
            const invalidFiles = fileArray.filter(file => file.size > bytes).map(file => ({ name: file.name, size: file.size }));
            return !invalidFiles.length
                ? null
                : {
                    maxFileSize: {
                        maxSize: bytes,
                        actualSizes: invalidFiles
                    }
                };
        };
    }
    static maxTotalSize(bytes) {
        return (control) => {
            const size = (control === null || control === void 0 ? void 0 : control.value) ? control.value.map(file => file.size).reduce((acc, i) => acc + i, 0) : 0;
            const result = bytes >= size;
            return result
                ? null
                : {
                    maxTotalSize: {
                        maxSize: bytes,
                        actualSize: size
                    }
                };
        };
    }
    static required(control) {
        var _a;
        const count = (_a = control === null || control === void 0 ? void 0 : control.value) === null || _a === void 0 ? void 0 : _a.length;
        return count
            ? null
            : {
                required: true
            };
    }
}

/*
 * Public API Surface of ngx-file-drag-drop
 */

/**
 * Generated bundle index. Do not edit.
 */

export { BytePipe, FileValidators, NgxFileDragDropComponent, NgxFileDragDropModule };
//# sourceMappingURL=ngx-file-drag-drop.js.map
